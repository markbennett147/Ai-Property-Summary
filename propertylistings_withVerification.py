import anthropic
import pandas as pd
import os
import re
from tqdm import tqdm

# Set the API key
os.environ["ANTHROPIC_API_KEY"] = "(API Key)"

# Initialize the Anthropic client
client = anthropic.Anthropic()

def extract_property_details(file_path, description_column="description", model="claude-3-7-sonnet-20250219", max_tokens=500):
    # Read the CSV file
    df = pd.read_csv(file_path)
    
    # Check if the description column exists
    if description_column not in df.columns:
        raise ValueError(f"Column '{description_column}' not found in CSV file. Available columns: {', '.join(df.columns)}")
    
    # Create new columns for the property details
    df['summary'] = None
    df['has_parking'] = None
    df['has_garden'] = None
    df['square_ft'] = None
    df['square_meters'] = None
    df['verification_status'] = None
    df['correction_needed'] = None
    df['correction_applied'] = None
    
    # Create a progress bar
    print("Extracting property details:")
    progress_bar = tqdm(total=len(df), desc="Processing properties", unit="property")
    
    # Process each property description
    for index, row in df.iterrows():
        description = row[description_column]
        
        # Update the progress bar description
        progress_bar.set_description(f"Processing property {index+1}/{len(df)}")
        
        # Skip empty descriptions
        if pd.isna(description) or description.strip() == "":
            df.at[index, 'summary'] = "No description available"
            df.at[index, 'has_parking'] = False
            df.at[index, 'has_garden'] = False
            df.at[index, 'square_ft'] = "Unknown"
            df.at[index, 'square_meters'] = "Unknown"
            df.at[index, 'verification_status'] = "N/A - Empty description"
            df.at[index, 'correction_needed'] = False
            df.at[index, 'correction_applied'] = False
            progress_bar.update(1)
            continue
            
        # Prompt the model to extract property details
        prompt = f"""Many property descriptions on the PDP are long and unstructured, making it difficult for buyers to quickly extract the most relevant information.
Users often skim through large blocks of text to find key details such as standout features, recent renovations, or unique selling points. This creates unnecessary cognitive load and can lead to frustration or disengagement, especially on mobile devices where long text blocks are harder to navigate.
Hypothesis
If we introduce a Property Insight Summary—an automatically generated, concise summary that extracts the most important details from the full description—we can:
Improve readability , allowing users to quickly grasp key property highlights without wading through long text.
Enhance engagement, as users are more likely to stay on the page when information is presented in a structured, easy-to-digest format.
Reduce cognitive overload, making it easier for buyers to compare listings and focus on the most relevant details.
The Property Insight Summary could be generated by:
Identifying key features (e.g., no of rooms & their size, standout amenities, recent upgrades).
Extracting important selling points (e.g., "Recently renovated kitchen with marble countertops").
Presenting the information in a short bullet-point format or a concise paragraph above the full description.

Extract the following details from this property description:

Property description:
{description}

Please respond ONLY with five lines in exactly this format:
SUMMARY: [A concise summary highlighting key features, amenities, location benefits, and unique selling points. Please don't include any adjectives or hyperboles.]
PARKING: [YES or NO - if there's any mention of parking, garage, carport, driveway]
GARDEN: [YES or NO - if there's any mention of garden, yard, outdoor space, patio]
SQUARE_FT: [Just the number, or UNKNOWN if not mentioned]
SQUARE_METERS: [Just the number, or UNKNOWN if not mentioned]

If square footage/meters information isn't directly mentioned, but one can be calculated from the other, please do the conversion (1 sq ft ≈ 0.093 sq meters) and provide both values.
"""
        
        try:
            # Initial extraction
            response = client.messages.create(
                model=model,
                max_tokens=max_tokens,
                system="You are a real estate data analyst who extracts accurate property details from descriptions.",
                messages=[
                    {"role": "user", "content": prompt}
                ]
            )
            
            # Get the response text and split by lines
            response_text = response.content[0].text.strip()
            lines = response_text.split('\n')
            
            # Extract the details from each line
            summary = ""
            has_parking = False
            has_garden = False
            square_ft = "Unknown"
            square_meters = "Unknown"
            
            for line in lines:
                if line.startswith("SUMMARY:"):
                    summary = line[len("SUMMARY:"):].strip()
                elif line.startswith("PARKING:"):
                    parking_value = line[len("PARKING:"):].strip().upper()
                    has_parking = (parking_value == "YES")
                elif line.startswith("GARDEN:"):
                    garden_value = line[len("GARDEN:"):].strip().upper()
                    has_garden = (garden_value == "YES")
                elif line.startswith("SQUARE_FT:"):
                    sq_ft_value = line[len("SQUARE_FT:"):].strip()
                    if sq_ft_value.upper() != "UNKNOWN" and re.match(r'^\d+$', sq_ft_value):
                        square_ft = int(sq_ft_value)
                elif line.startswith("SQUARE_METERS:"):
                    sq_m_value = line[len("SQUARE_METERS:"):].strip()
                    if sq_m_value.upper() != "UNKNOWN" and re.match(r'^\d+$', sq_m_value):
                        square_meters = int(sq_m_value)
            
            # VERIFICATION STEP: Add detailed verification to confirm extracted information
            verification_prompt = f"""Verify if the following extracted details accurately reflect the information in the original property description.
Be thorough and detailed in your verification process.

Original property description:
{description}

Extracted details:
Summary: {summary}
Has parking: {"Yes" if has_parking else "No"}
Has garden: {"Yes" if has_garden else "No"}
Square feet: {square_ft}
Square meters: {square_meters}

For each detail, verify if the extraction is accurate. Please respond in this exact format:

VERIFICATION_STATUS: [ACCURATE, PARTIALLY_ACCURATE, INACCURATE]
ISSUES_FOUND: [YES or NO]
PARKING_CORRECT: [YES or NO]
GARDEN_CORRECT: [YES or NO]
SQUARE_FT_CORRECT: [YES or NO]
SQUARE_METERS_CORRECT: [YES or NO]
SUMMARY_CORRECT: [YES or NO]
CORRECTION_DETAILS: [Provide specific corrections needed for each inaccurate field]
"""
            
            # Perform detailed verification
            verification_response = client.messages.create(
                model=model,
                max_tokens=max_tokens,
                system="You are a meticulous property data validator who carefully checks extracted information against source descriptions.",
                messages=[
                    {"role": "user", "content": verification_prompt}
                ]
            )
            
            verification_text = verification_response.content[0].text.strip()
            
            # Parse verification status
            verification_status = "Unknown"
            issues_found = False
            parking_correct = True
            garden_correct = True
            square_ft_correct = True
            square_meters_correct = True
            summary_correct = True
            correction_details = None
            
            for line in verification_text.split('\n'):
                if line.startswith("VERIFICATION_STATUS:"):
                    verification_status = line[len("VERIFICATION_STATUS:"):].strip()
                elif line.startswith("ISSUES_FOUND:"):
                    issues_found = line[len("ISSUES_FOUND:"):].strip().upper() == "YES"
                elif line.startswith("PARKING_CORRECT:"):
                    parking_correct = line[len("PARKING_CORRECT:"):].strip().upper() == "YES"
                elif line.startswith("GARDEN_CORRECT:"):
                    garden_correct = line[len("GARDEN_CORRECT:"):].strip().upper() == "YES"
                elif line.startswith("SQUARE_FT_CORRECT:"):
                    square_ft_correct = line[len("SQUARE_FT_CORRECT:"):].strip().upper() == "YES"
                elif line.startswith("SQUARE_METERS_CORRECT:"):
                    square_meters_correct = line[len("SQUARE_METERS_CORRECT:"):].strip().upper() == "YES"
                elif line.startswith("SUMMARY_CORRECT:"):
                    summary_correct = line[len("SUMMARY_CORRECT:"):].strip().upper() == "YES"
                elif line.startswith("CORRECTION_DETAILS:"):
                    correction_details = line[len("CORRECTION_DETAILS:"):].strip()
            
            # CORRECTION STEP: If verification found issues, correct them
            correction_applied = False
            
            if issues_found:
                # Direct rule-based corrections first
                if not parking_correct:
                    # Direct check in the original description
                    parking_keywords = ["parking", "garage", "carport", "driveway", "parking space", "car port", "off-street parking"]
                    new_has_parking = any(keyword in description.lower() for keyword in parking_keywords)
                    if new_has_parking != has_parking:
                        has_parking = new_has_parking
                        correction_applied = True
                
                if not garden_correct:
                    # Direct check in the original description
                    garden_keywords = ["garden", "yard", "outdoor space", "patio", "lawn", "backyard", "front yard", "terrace"]
                    new_has_garden = any(keyword in description.lower() for keyword in garden_keywords)
                    if new_has_garden != has_garden:
                        has_garden = new_has_garden
                        correction_applied = True
                
                if not square_ft_correct:
                    # Try to find square footage in original description
                    sq_ft_patterns = [
                        r'(\d+)\s*(?:square feet|sq\.?\s*ft\.?|sq\.?\s*foot|sq\.?\s*footage)',
                        r'(\d+)\s*(?:ft2|ft²)', 
                        r'area of (\d+)\s*(?:sq\.?\s*ft\.?)',
                        r'(\d+)\s*(?:sqft|sq ft)'
                    ]
                    
                    for pattern in sq_ft_patterns:
                        sq_ft_match = re.search(pattern, description.lower())
                        if sq_ft_match:
                            new_square_ft = int(sq_ft_match.group(1))
                            if square_ft != new_square_ft:
                                square_ft = new_square_ft
                                correction_applied = True
                            break
                    
                if not square_meters_correct:
                    # Try to find square meters in original description
                    sq_m_patterns = [
                        r'(\d+)\s*(?:square meters|sq\.?\s*m\.?|square metres)',
                        r'(\d+)\s*(?:m2|m²)',
                        r'area of (\d+)\s*(?:sq\.?\s*m\.?)',
                        r'(\d+)\s*(?:sqm|sq m)'
                    ]
                    
                    for pattern in sq_m_patterns:
                        sq_m_match = re.search(pattern, description.lower())
                        if sq_m_match:
                            new_square_meters = int(sq_m_match.group(1))
                            if square_meters != new_square_meters:
                                square_meters = new_square_meters
                                correction_applied = True
                            break
                
                # If direct corrections didn't fix everything, use Claude to generate corrections
                if not correction_applied or not summary_correct:
                    correction_prompt = f"""The following property details were extracted incorrectly or incompletely. 
Please provide corrected values based on the original description.

Original property description:
{description}

Current extracted details:
Summary: {summary}
Has parking: {"Yes" if has_parking else "No"}
Has garden: {"Yes" if has_garden else "No"}
Square feet: {square_ft}
Square meters: {square_meters}

Issues identified: {correction_details}

Please provide ONLY the corrected values in this exact format:
CORRECTED_SUMMARY: [Corrected summary]
CORRECTED_PARKING: [YES or NO]
CORRECTED_GARDEN: [YES or NO]
CORRECTED_SQUARE_FT: [Corrected value or UNKNOWN]
CORRECTED_SQUARE_METERS: [Corrected value or UNKNOWN]
"""

                    correction_response = client.messages.create(
                        model=model,
                        max_tokens=max_tokens,
                        system="You are a real estate data correction specialist who fixes extracted property information with great precision.",
                        messages=[
                            {"role": "user", "content": correction_prompt}
                        ]
                    )
                    
                    correction_text = correction_response.content[0].text.strip()
                    
                    # Parse corrected values
                    for line in correction_text.split('\n'):
                        if line.startswith("CORRECTED_SUMMARY:"):
                            new_summary = line[len("CORRECTED_SUMMARY:"):].strip()
                            if new_summary != summary:
                                summary = new_summary
                                correction_applied = True
                        elif line.startswith("CORRECTED_PARKING:"):
                            new_parking_value = line[len("CORRECTED_PARKING:"):].strip().upper() == "YES"
                            if new_parking_value != has_parking:
                                has_parking = new_parking_value
                                correction_applied = True
                        elif line.startswith("CORRECTED_GARDEN:"):
                            new_garden_value = line[len("CORRECTED_GARDEN:"):].strip().upper() == "YES"
                            if new_garden_value != has_garden:
                                has_garden = new_garden_value
                                correction_applied = True
                        elif line.startswith("CORRECTED_SQUARE_FT:"):
                            sq_ft_value = line[len("CORRECTED_SQUARE_FT:"):].strip()
                            if sq_ft_value.upper() != "UNKNOWN" and re.match(r'^\d+$', sq_ft_value):
                                new_square_ft = int(sq_ft_value)
                                if new_square_ft != square_ft:
                                    square_ft = new_square_ft
                                    correction_applied = True
                        elif line.startswith("CORRECTED_SQUARE_METERS:"):
                            sq_m_value = line[len("CORRECTED_SQUARE_METERS:"):].strip()
                            if sq_m_value.upper() != "UNKNOWN" and re.match(r'^\d+$', sq_m_value):
                                new_square_meters = int(sq_m_value)
                                if new_square_meters != square_meters:
                                    square_meters = new_square_meters
                                    correction_applied = True
            
            # Store the extracted and verified details
            df.at[index, 'summary'] = summary
            df.at[index, 'has_parking'] = has_parking
            df.at[index, 'has_garden'] = has_garden
            df.at[index, 'square_ft'] = square_ft
            df.at[index, 'square_meters'] = square_meters
            df.at[index, 'verification_status'] = verification_status
            df.at[index, 'correction_needed'] = issues_found
            df.at[index, 'correction_applied'] = correction_applied
            
        except Exception as e:
            print(f"\nError processing property {index+1}: {e}")
            df.at[index, 'summary'] = "Error extracting details"
            df.at[index, 'verification_status'] = "ERROR"
            df.at[index, 'correction_needed'] = True
            df.at[index, 'correction_applied'] = False
        
        # Update the progress bar
        progress_bar.update(1)
    
    # Close the progress bar
    progress_bar.close()
    
    # Convert boolean columns to proper boolean type
    df['has_parking'] = df['has_parking'].fillna(False).astype(bool)
    df['has_garden'] = df['has_garden'].fillna(False).astype(bool)
    df['correction_needed'] = df['correction_needed'].fillna(False).astype(bool)
    df['correction_applied'] = df['correction_applied'].fillna(False).astype(bool)
    
    # Try to fill in missing square footage/meters by calculating from the other
    for index, row in df.iterrows():
        if isinstance(row['square_ft'], (int, float)) and row['square_ft'] > 0 and (pd.isna(row['square_meters']) or row['square_meters'] == "Unknown"):
            df.at[index, 'square_meters'] = int(row['square_ft'] * 0.093)
        elif isinstance(row['square_meters'], (int, float)) and row['square_meters'] > 0 and (pd.isna(row['square_ft']) or row['square_ft'] == "Unknown"):
            df.at[index, 'square_ft'] = int(row['square_meters'] / 0.093)
    
    # Generate verification and correction statistics
    accurate_count = sum(df['verification_status'] == "ACCURATE")
    partial_count = sum(df['verification_status'] == "PARTIALLY_ACCURATE")
    inaccurate_count = sum(df['verification_status'] == "INACCURATE")
    error_count = sum(df['verification_status'] == "ERROR")
    
    correction_needed_count = sum(df['correction_needed'] == True)
    correction_applied_count = sum(df['correction_applied'] == True)
    
    print("\nVerification Results:")
    print(f"Accurate extractions: {accurate_count} ({accurate_count/len(df)*100:.1f}%)")
    print(f"Partially accurate extractions: {partial_count} ({partial_count/len(df)*100:.1f}%)")
    print(f"Inaccurate extractions: {inaccurate_count} ({inaccurate_count/len(df)*100:.1f}%)")
    print(f"Processing errors: {error_count} ({error_count/len(df)*100:.1f}%)")
    
    print("\nCorrection Results:")
    print(f"Properties needing correction: {correction_needed_count} ({correction_needed_count/len(df)*100:.1f}%)")
    print(f"Properties successfully corrected: {correction_applied_count} ({correction_applied_count/len(df)*100:.1f}%)")
    print(f"Correction success rate: {correction_applied_count/max(correction_needed_count, 1)*100:.1f}%")
    
    # Save the results to a new CSV file
    output_path = file_path.replace('.csv', ' verified and corrected.csv')
    if output_path == file_path:  # In case the input file doesn't have a .csv extension
        output_path = file_path + ' verified and corrected.csv'
    
    df.to_csv(output_path, index=False)
    print(f"\nVerified and corrected property details saved to {output_path}")
    
    return df

# Local file path to the CSV file
file_path = "(CSV File Path)"

# Column name that contains the property descriptions
description_column = "description"

# Process the CSV file
results = extract_property_details(file_path, description_column)

# Display a few examples of the extracted details
print("\nExample property details:")
sample = min(3, len(results))  # Show up to three examples
for i in range(sample):
    print(f"\nProperty {i+1}:")
    print(f"Summary: {results['summary'].iloc[i]}")
    print(f"Has Parking: {results['has_parking'].iloc[i]}")
    print(f"Has Garden: {results['has_garden'].iloc[i]}")
    print(f"Square Feet: {results['square_ft'].iloc[i]}")
    print(f"Square Meters: {results['square_meters'].iloc[i]}")
    print(f"Verification Status: {results['verification_status'].iloc[i]}")
    if results['correction_needed'].iloc[i]:
        print(f"Correction Applied: {results['correction_applied'].iloc[i]}")
