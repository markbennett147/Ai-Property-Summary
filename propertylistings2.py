import anthropic
import pandas as pd
import os
from tqdm import tqdm

# Set the API key
os.environ["ANTHROPIC_API_KEY"] = "(API key)"

# Initialize the Anthropic client
client = anthropic.Anthropic()

def extract_property_details(file_path, description_column="description", model="claude-3-7-sonnet-20250219", max_tokens=500):
    # Read the CSV file
    df = pd.read_csv(file_path)
    
    # Check if the description column exists
    if description_column not in df.columns:
        raise ValueError(f"Column '{description_column}' not found in CSV file. Available columns: {', '.join(df.columns)}")
    
    # Create new columns for the property details
    df['summary'] = None
    df['has_parking'] = None
    df['has_garden'] = None
    df['square_ft'] = None
    df['square_meters'] = None
    
    # Create a progress bar
    print("Extracting property details:")
    progress_bar = tqdm(total=len(df), desc="Processing properties", unit="property")
    
    # Process each property description
    for index, row in df.iterrows():
        description = row[description_column]
        
        # Update the progress bar description to show which property is being processed
        progress_bar.set_description(f"Processing property {index+1}/{len(df)}")
        
        # Skip empty descriptions
        if pd.isna(description) or description.strip() == "":
            df.at[index, 'summary'] = "No description available"
            df.at[index, 'has_parking'] = False
            df.at[index, 'has_garden'] = False
            progress_bar.update(1)
            continue
            
        # Prompt the model to extract property details
        prompt = f"""Many property descriptions on the PDP are long and unstructured, making it difficult for buyers to quickly extract the most relevant information.
Users often skim through large blocks of text to find key details such as standout features, recent renovations, or unique selling points. This creates unnecessary cognitive load and can lead to frustration or disengagement, especially on mobile devices where long text blocks are harder to navigate.
Hypothesis
If we introduce a Property Insight Summary—an automatically generated, concise summary that extracts the most important details from the full description—we can:
Improve readability , allowing users to quickly grasp key property highlights without wading through long text.
Enhance engagement, as users are more likely to stay on the page when information is presented in a structured, easy-to-digest format.
Reduce cognitive overload, making it easier for buyers to compare listings and focus on the most relevant details.
The Property Insight Summary could be generated by:
Identifying key features (e.g., no of rooms & their size, standout amenities, recent upgrades).
Extracting important selling points (e.g., "Recently renovated kitchen with marble countertops").
Presenting the information in a short bullet-point format or a concise paragraph above the full description.

Extract the following details from this property description:

Property description:
{description}

Please respond ONLY with five lines in exactly this format:
SUMMARY: [A concise summary highlighting key features, amenities, location benefits, and unique selling points. Please don't include any adjectives or hyperboles.]
PARKING: [YES or NO - if there's any mention of parking, garage, carport, driveway]
GARDEN: [YES or NO - if there's any mention of garden, yard, outdoor space, patio]
SQUARE_FT: [Just the number, or UNKNOWN if not mentioned]
SQUARE_METERS: [Just the number, or UNKNOWN if not mentioned]

If square footage/meters information isn't directly mentioned, but one can be calculated from the other, please do the conversion (1 sq ft ≈ 0.093 sq meters) and provide both values.
"""
        
        try:
            response = client.messages.create(
                model=model,
                max_tokens=max_tokens,
                system="You are a real estate data analyst who extracts accurate property details from descriptions.",
                messages=[
                    {"role": "user", "content": prompt}
                ]
            )
            
            # Get the response text and split by lines
            response_text = response.content[0].text.strip()
            lines = response_text.split('\n')
            
            # Extract the details from each line
            summary = ""
            has_parking = False
            has_garden = False
            square_ft = "Unknown"
            square_meters = "Unknown"
            
            for line in lines:
                if line.startswith("SUMMARY:"):
                    summary = line[len("SUMMARY:"):].strip()
                elif line.startswith("PARKING:"):
                    parking_value = line[len("PARKING:"):].strip().upper()
                    has_parking = (parking_value == "YES")
                elif line.startswith("GARDEN:"):
                    garden_value = line[len("GARDEN:"):].strip().upper()
                    has_garden = (garden_value == "YES")
                elif line.startswith("SQUARE_FT:"):
                    sq_ft_value = line[len("SQUARE_FT:"):].strip()
                    if sq_ft_value.isdigit():
                        square_ft = int(sq_ft_value)
                elif line.startswith("SQUARE_METERS:"):
                    sq_m_value = line[len("SQUARE_METERS:"):].strip()
                    if sq_m_value.isdigit():
                        square_meters = int(sq_m_value)
            
            # Store the extracted details
            df.at[index, 'summary'] = summary
            df.at[index, 'has_parking'] = has_parking
            df.at[index, 'has_garden'] = has_garden
            df.at[index, 'square_ft'] = square_ft
            df.at[index, 'square_meters'] = square_meters
            
        except Exception as e:
            print(f"\nError processing property {index+1}: {e}")
            df.at[index, 'summary'] = "Error extracting details"
        
        # Update the progress bar
        progress_bar.update(1)
    
    # Close the progress bar
    progress_bar.close()
    
    # Convert boolean columns to proper boolean type
    df['has_parking'] = df['has_parking'].fillna(False).astype(bool)
    df['has_garden'] = df['has_garden'].fillna(False).astype(bool)
    
    # Try to fill in missing square footage/meters by calculating from the other
    for index, row in df.iterrows():
        if pd.notna(row['square_ft']) and pd.isna(row['square_meters']):
            df.at[index, 'square_meters'] = int(row['square_ft'] * 0.093)
        elif pd.isna(row['square_ft']) and pd.notna(row['square_meters']):
            df.at[index, 'square_ft'] = int(row['square_meters'] / 0.093)
    
    # Save the results to a new CSV file
    output_path = file_path.replace('.csv', ' with summary.csv')
    if output_path == file_path:  # In case the input file doesn't have a .csv extension
        output_path = file_path + ' with summary.csv'
    
    df.to_csv(output_path, index=False)
    print(f"\nProperty details saved to {output_path}")
    
    return df

# Local file path to the CSV file
file_path = "(CSV file path)"

# Column name that contains the property descriptions
description_column = "description"

# Process the CSV file
results = extract_property_details(file_path, description_column)

# Display a few examples of the extracted details
print("\nExample property details:")
sample = min(1, len(results))  # Show one example
for i in range(sample):
    print(f"\nProperty {i+1}:")
    print(f"Summary: {results['summary'].iloc[i]}")
    print(f"Has Parking: {results['has_parking'].iloc[i]}")
    print(f"Has Garden: {results['has_garden'].iloc[i]}")
    print(f"Square Feet: {results['square_ft'].iloc[i]}")
    print(f"Square Meters: {results['square_meters'].iloc[i]}")
